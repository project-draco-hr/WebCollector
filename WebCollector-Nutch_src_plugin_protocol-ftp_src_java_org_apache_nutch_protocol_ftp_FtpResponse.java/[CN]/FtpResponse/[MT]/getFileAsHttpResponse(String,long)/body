{
  ByteArrayOutputStream os=null;
  List<FTPFile> list=null;
  try {
    list=new LinkedList<FTPFile>();
    ftp.client.retrieveList(path,list,ftp.maxContentLength,ftp.parser);
    FTPFile ftpFile=(FTPFile)list.get(0);
    this.headers.set(Response.CONTENT_LENGTH,new Long(ftpFile.getSize()).toString());
    this.headers.set(Response.LAST_MODIFIED,HttpDateFormat.toString(ftpFile.getTimestamp()));
    if (ftpFile.getTimestamp().getTimeInMillis() <= lastModified) {
      code=304;
      return;
    }
    os=new ByteArrayOutputStream(ftp.getBufferSize());
    ftp.client.retrieveFile(path,os,ftp.maxContentLength);
    this.content=os.toByteArray();
    this.code=200;
  }
 catch (  FtpExceptionControlClosedByForcedDataClose e) {
    if ((ftp.followTalk) && (Ftp.LOG.isInfoEnabled())) {
      Ftp.LOG.info("delete client because server cut off control channel: " + e);
    }
    ftp.client=null;
    if (os == null) {
      if (Ftp.LOG.isWarnEnabled()) {
        Ftp.LOG.warn("Please try larger maxContentLength for ftp.client.retrieveList(). " + e);
      }
      this.code=400;
      return;
    }
    FTPFile ftpFile=(FTPFile)list.get(0);
    this.headers.set(Response.CONTENT_LENGTH,new Long(ftpFile.getSize()).toString());
    this.headers.set(Response.LAST_MODIFIED,HttpDateFormat.toString(ftpFile.getTimestamp()));
    this.content=os.toByteArray();
    if (ftpFile.getTimestamp().getTimeInMillis() <= lastModified) {
      code=304;
      return;
    }
    this.code=200;
  }
catch (  FtpExceptionCanNotHaveDataConnection e) {
    if (FTPReply.isPositiveCompletion(ftp.client.cwd(path))) {
      this.headers.set(Response.LOCATION,path + "/");
      this.code=300;
    }
 else {
      this.code=404;
    }
  }
catch (  FtpExceptionUnknownForcedDataClose e) {
    if (Ftp.LOG.isWarnEnabled()) {
      Ftp.LOG.warn("Unrecognized reply after forced close of data channel. " + "If this is acceptable, please modify Client.java accordingly. " + e);
    }
    this.code=400;
  }
}
