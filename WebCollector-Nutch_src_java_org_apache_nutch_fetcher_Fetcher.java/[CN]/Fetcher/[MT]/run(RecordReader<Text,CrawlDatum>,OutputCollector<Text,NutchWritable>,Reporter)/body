{
  this.output=output;
  this.reporter=reporter;
  this.fetchQueues=new FetchItemQueues(getConf());
  int threadCount=getConf().getInt("fetcher.threads.fetch",10);
  if (LOG.isInfoEnabled()) {
    LOG.info("Fetcher: threads: " + threadCount);
  }
  int timeoutDivisor=getConf().getInt("fetcher.threads.timeout.divisor",2);
  if (LOG.isInfoEnabled()) {
    LOG.info("Fetcher: time-out divisor: " + timeoutDivisor);
  }
  int queueDepthMuliplier=getConf().getInt("fetcher.queue.depth.multiplier",50);
  feeder=new QueueFeeder(input,fetchQueues,threadCount * queueDepthMuliplier);
  long timelimit=getConf().getLong("fetcher.timelimit",-1);
  if (timelimit != -1)   feeder.setTimeLimit(timelimit);
  feeder.start();
  getConf().setBoolean(Protocol.CHECK_BLOCKING,false);
  getConf().setBoolean(Protocol.CHECK_ROBOTS,false);
  for (int i=0; i < threadCount; i++) {
    FetcherThread t=new FetcherThread(getConf());
    fetcherThreads.add(t);
    t.start();
  }
  long timeout=getConf().getInt("mapred.task.timeout",10 * 60 * 1000) / timeoutDivisor;
  int pagesLastSec;
  int bytesLastSec;
  boolean throughputThresholdExceeded=false;
  int throughputThresholdNumRetries=0;
  int throughputThresholdPages=getConf().getInt("fetcher.throughput.threshold.pages",-1);
  if (LOG.isInfoEnabled()) {
    LOG.info("Fetcher: throughput threshold: " + throughputThresholdPages);
  }
  int throughputThresholdMaxRetries=getConf().getInt("fetcher.throughput.threshold.retries",5);
  if (LOG.isInfoEnabled()) {
    LOG.info("Fetcher: throughput threshold retries: " + throughputThresholdMaxRetries);
  }
  long throughputThresholdTimeLimit=getConf().getLong("fetcher.throughput.threshold.check.after",-1);
  int targetBandwidth=getConf().getInt("fetcher.bandwidth.target",-1) * 1000;
  int maxNumThreads=getConf().getInt("fetcher.maxNum.threads",threadCount);
  if (maxNumThreads < threadCount) {
    LOG.info("fetcher.maxNum.threads can't be < than " + threadCount + " : using "+ threadCount+ " instead");
    maxNumThreads=threadCount;
  }
  int bandwidthTargetCheckEveryNSecs=getConf().getInt("fetcher.bandwidth.target.check.everyNSecs",30);
  if (bandwidthTargetCheckEveryNSecs < 1) {
    LOG.info("fetcher.bandwidth.target.check.everyNSecs can't be < to 1 : using 1 instead");
    bandwidthTargetCheckEveryNSecs=1;
  }
  int maxThreadsPerQueue=getConf().getInt("fetcher.threads.per.queue",1);
  int bandwidthTargetCheckCounter=0;
  long bytesAtLastBWTCheck=0l;
  do {
    pagesLastSec=pages.get();
    bytesLastSec=(int)bytes.get();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    pagesLastSec=pages.get() - pagesLastSec;
    bytesLastSec=(int)bytes.get() - bytesLastSec;
    reporter.incrCounter("FetcherStatus","bytes_downloaded",bytesLastSec);
    reportStatus(pagesLastSec,bytesLastSec);
    LOG.info("-activeThreads=" + activeThreads + ", spinWaiting="+ spinWaiting.get()+ ", fetchQueues.totalSize="+ fetchQueues.getTotalSize()+ ", fetchQueues.getQueueCount="+ fetchQueues.getQueueCount());
    if (!feeder.isAlive() && fetchQueues.getTotalSize() < 5) {
      fetchQueues.dump();
    }
    if (throughputThresholdTimeLimit < System.currentTimeMillis() && throughputThresholdPages != -1) {
      if (pagesLastSec < throughputThresholdPages) {
        throughputThresholdNumRetries++;
        LOG.warn(Integer.toString(throughputThresholdNumRetries) + ": dropping below configured threshold of " + Integer.toString(throughputThresholdPages)+ " pages per second");
        if (throughputThresholdNumRetries == throughputThresholdMaxRetries) {
          LOG.warn("Dropped below threshold too many times, killing!");
          throughputThresholdPages=-1;
          int hitByThrougputThreshold=fetchQueues.emptyQueues();
          if (hitByThrougputThreshold != 0)           reporter.incrCounter("FetcherStatus","hitByThrougputThreshold",hitByThrougputThreshold);
        }
      }
    }
    if (targetBandwidth > 0) {
      if (bandwidthTargetCheckCounter < bandwidthTargetCheckEveryNSecs)       bandwidthTargetCheckCounter++;
 else       if (bandwidthTargetCheckCounter == bandwidthTargetCheckEveryNSecs) {
        long bpsSinceLastCheck=((bytes.get() - bytesAtLastBWTCheck) * 8) / bandwidthTargetCheckEveryNSecs;
        bytesAtLastBWTCheck=bytes.get();
        bandwidthTargetCheckCounter=0;
        int averageBdwPerThread=0;
        if (activeThreads.get() > 0)         averageBdwPerThread=Math.round(bpsSinceLastCheck / activeThreads.get());
        LOG.info("averageBdwPerThread : " + (averageBdwPerThread / 1000) + " kbps");
        if (bpsSinceLastCheck < targetBandwidth && averageBdwPerThread > 0) {
          if ((fetchQueues.getQueueCount() * maxThreadsPerQueue) > activeThreads.get()) {
            long remainingBdw=targetBandwidth - bpsSinceLastCheck;
            int additionalThreads=Math.round(remainingBdw / averageBdwPerThread);
            int availableThreads=maxNumThreads - activeThreads.get();
            additionalThreads=(availableThreads < additionalThreads ? availableThreads : additionalThreads);
            LOG.info("Has space for more threads (" + (bpsSinceLastCheck / 1000) + " vs "+ (targetBandwidth / 1000)+ " kbps) \t=> adding "+ additionalThreads+ " new threads");
            for (int i=0; i < additionalThreads; i++) {
              FetcherThread thread=new FetcherThread(getConf());
              fetcherThreads.add(thread);
              thread.start();
            }
          }
        }
 else         if (bpsSinceLastCheck > targetBandwidth && averageBdwPerThread > 0) {
          long excessBdw=bpsSinceLastCheck - targetBandwidth;
          int excessThreads=Math.round(excessBdw / averageBdwPerThread);
          LOG.info("Exceeding target bandwidth (" + bpsSinceLastCheck / 1000 + " vs " + (targetBandwidth / 1000) + " kbps). \t=> excessThreads = " + excessThreads);
          if (excessThreads >= fetcherThreads.size())           excessThreads=0;
          for (int i=0; i < excessThreads; i++) {
            FetcherThread thread=fetcherThreads.removeLast();
            thread.setHalted(true);
          }
        }
      }
    }
    if (!feeder.isAlive()) {
      int hitByTimeLimit=fetchQueues.checkTimelimit();
      if (hitByTimeLimit != 0)       reporter.incrCounter("FetcherStatus","hitByTimeLimit",hitByTimeLimit);
    }
    if ((System.currentTimeMillis() - lastRequestStart.get()) > timeout) {
      if (LOG.isWarnEnabled()) {
        LOG.warn("Aborting with " + activeThreads + " hung threads.");
        for (int i=0; i < fetcherThreads.size(); i++) {
          FetcherThread thread=fetcherThreads.get(i);
          if (thread.isAlive()) {
            LOG.warn("Thread #" + i + " hung while processing "+ thread.reprUrl);
            if (LOG.isDebugEnabled()) {
              StackTraceElement[] stack=thread.getStackTrace();
              StringBuilder sb=new StringBuilder();
              sb.append("Stack of thread #").append(i).append(":\n");
              for (              StackTraceElement s : stack) {
                sb.append(s.toString()).append('\n');
              }
              LOG.debug(sb.toString());
            }
          }
        }
      }
      return;
    }
  }
 while (activeThreads.get() > 0);
  LOG.info("-activeThreads=" + activeThreads);
}
