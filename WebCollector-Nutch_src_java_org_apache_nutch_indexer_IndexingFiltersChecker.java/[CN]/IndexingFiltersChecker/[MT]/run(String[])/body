{
  String contentType=null;
  String url=null;
  boolean dumpText=false;
  String usage="Usage: IndexingFiltersChecker [-dumpText] <url>";
  if (args.length == 0) {
    System.err.println(usage);
    return -1;
  }
  for (int i=0; i < args.length; i++) {
    if (args[i].equals("-dumpText")) {
      dumpText=true;
    }
 else     if (i != args.length - 1) {
      System.err.println(usage);
      System.exit(-1);
    }
 else {
      url=URLUtil.toASCII(args[i]);
    }
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("fetching: " + url);
  }
  IndexingFilters indexers=new IndexingFilters(conf);
  ProtocolFactory factory=new ProtocolFactory(conf);
  Protocol protocol=factory.getProtocol(url);
  CrawlDatum datum=new CrawlDatum();
  ProtocolOutput output=protocol.getProtocolOutput(new Text(url),datum);
  IndexWriters writers=new IndexWriters(getConf());
  if (!output.getStatus().isSuccess()) {
    System.out.println("Fetch failed with protocol status: " + output.getStatus());
    return 0;
  }
  Content content=output.getContent();
  if (content == null) {
    System.out.println("No content for " + url);
    return 0;
  }
  contentType=content.getContentType();
  if (contentType == null) {
    return -1;
  }
  datum.getMetaData().put(new Text(Metadata.CONTENT_TYPE),new Text(contentType));
  if (ParseSegment.isTruncated(content)) {
    LOG.warn("Content is truncated, parse may fail!");
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("parsing: " + url);
    LOG.info("contentType: " + contentType);
  }
  ParseResult parseResult=new ParseUtil(conf).parse(content);
  NutchDocument doc=new NutchDocument();
  doc.add("id",url);
  Text urlText=new Text(url);
  Inlinks inlinks=null;
  Parse parse=parseResult.get(urlText);
  byte[] signature=SignatureFactory.getSignature(conf).calculate(content,parse);
  parse.getData().getContentMeta().set(Nutch.SIGNATURE_KEY,StringUtil.toHexString(signature));
  String digest=parse.getData().getContentMeta().get(Nutch.SIGNATURE_KEY);
  doc.add("digest",digest);
  try {
    doc=indexers.filter(doc,parse,urlText,datum,inlinks);
  }
 catch (  IndexingException e) {
    e.printStackTrace();
  }
  if (doc == null) {
    System.out.println("Document discarded by indexing filter");
    return 0;
  }
  for (  String fname : doc.getFieldNames()) {
    List<Object> values=doc.getField(fname).getValues();
    if (values != null) {
      for (      Object value : values) {
        String str=value.toString();
        int minText=dumpText ? str.length() : Math.min(100,str.length());
        System.out.println(fname + " :\t" + str.substring(0,minText));
      }
    }
  }
  if (conf.getBoolean("doIndex",false) && doc != null) {
    writers.open(new JobConf(getConf()),"IndexingFilterChecker");
    writers.write(doc);
    writers.close();
  }
  return 0;
}
