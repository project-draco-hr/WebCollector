{
  return new RecordWriter<Text,MetaWrapper>(){
    MapFile.Writer c_out=null;
    MapFile.Writer f_out=null;
    MapFile.Writer pd_out=null;
    MapFile.Writer pt_out=null;
    SequenceFile.Writer g_out=null;
    SequenceFile.Writer p_out=null;
    HashMap<String,Closeable> sliceWriters=new HashMap<String,Closeable>();
    String segmentName=job.get("segment.merger.segmentName");
    public void write(    Text key,    MetaWrapper wrapper) throws IOException {
      SegmentPart sp=SegmentPart.parse(wrapper.getMeta(SEGMENT_PART_KEY));
      Writable o=wrapper.get();
      String slice=wrapper.getMeta(SEGMENT_SLICE_KEY);
      if (o instanceof CrawlDatum) {
        if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {
          g_out=ensureSequenceFile(slice,CrawlDatum.GENERATE_DIR_NAME);
          g_out.append(key,o);
        }
 else         if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {
          f_out=ensureMapFile(slice,CrawlDatum.FETCH_DIR_NAME,CrawlDatum.class);
          f_out.append(key,o);
        }
 else         if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {
          p_out=ensureSequenceFile(slice,CrawlDatum.PARSE_DIR_NAME);
          p_out.append(key,o);
        }
 else {
          throw new IOException("Cannot determine segment part: " + sp.partName);
        }
      }
 else       if (o instanceof Content) {
        c_out=ensureMapFile(slice,Content.DIR_NAME,Content.class);
        c_out.append(key,o);
      }
 else       if (o instanceof ParseData) {
        if (slice == null) {
          ((ParseData)o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY,segmentName);
        }
 else {
          ((ParseData)o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY,segmentName + "-" + slice);
        }
        pd_out=ensureMapFile(slice,ParseData.DIR_NAME,ParseData.class);
        pd_out.append(key,o);
      }
 else       if (o instanceof ParseText) {
        pt_out=ensureMapFile(slice,ParseText.DIR_NAME,ParseText.class);
        pt_out.append(key,o);
      }
    }
    private SequenceFile.Writer ensureSequenceFile(    String slice,    String dirName) throws IOException {
      if (slice == null)       slice=DEFAULT_SLICE;
      SequenceFile.Writer res=(SequenceFile.Writer)sliceWriters.get(slice + dirName);
      if (res != null)       return res;
      Path wname;
      Path out=FileOutputFormat.getOutputPath(job);
      if (slice == DEFAULT_SLICE) {
        wname=new Path(new Path(new Path(out,segmentName),dirName),name);
      }
 else {
        wname=new Path(new Path(new Path(out,segmentName + "-" + slice),dirName),name);
      }
      res=SequenceFile.createWriter(fs,job,wname,Text.class,CrawlDatum.class,SequenceFileOutputFormat.getOutputCompressionType(job),progress);
      sliceWriters.put(slice + dirName,res);
      return res;
    }
    private MapFile.Writer ensureMapFile(    String slice,    String dirName,    Class<? extends Writable> clazz) throws IOException {
      if (slice == null)       slice=DEFAULT_SLICE;
      MapFile.Writer res=(MapFile.Writer)sliceWriters.get(slice + dirName);
      if (res != null)       return res;
      Path wname;
      Path out=FileOutputFormat.getOutputPath(job);
      if (slice == DEFAULT_SLICE) {
        wname=new Path(new Path(new Path(out,segmentName),dirName),name);
      }
 else {
        wname=new Path(new Path(new Path(out,segmentName + "-" + slice),dirName),name);
      }
      CompressionType compType=SequenceFileOutputFormat.getOutputCompressionType(job);
      if (clazz.isAssignableFrom(ParseText.class)) {
        compType=CompressionType.RECORD;
      }
      res=new MapFile.Writer(job,fs,wname.toString(),Text.class,clazz,compType,progress);
      sliceWriters.put(slice + dirName,res);
      return res;
    }
    public void close(    Reporter reporter) throws IOException {
      Iterator<Closeable> it=sliceWriters.values().iterator();
      while (it.hasNext()) {
        Object o=it.next();
        if (o instanceof SequenceFile.Writer) {
          ((SequenceFile.Writer)o).close();
        }
 else {
          ((MapFile.Writer)o).close();
        }
      }
    }
  }
;
}
