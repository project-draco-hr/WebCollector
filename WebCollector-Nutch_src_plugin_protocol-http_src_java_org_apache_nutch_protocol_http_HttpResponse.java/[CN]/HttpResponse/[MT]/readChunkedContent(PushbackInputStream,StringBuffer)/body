{
  boolean doneChunks=false;
  int contentBytesRead=0;
  byte[] bytes=new byte[Http.BUFFER_SIZE];
  ByteArrayOutputStream out=new ByteArrayOutputStream(Http.BUFFER_SIZE);
  while (!doneChunks) {
    if (Http.LOG.isTraceEnabled()) {
      Http.LOG.trace("Http: starting chunk");
    }
    readLine(in,line,false);
    String chunkLenStr;
    int pos=line.indexOf(";");
    if (pos < 0) {
      chunkLenStr=line.toString();
    }
 else {
      chunkLenStr=line.substring(0,pos);
    }
    chunkLenStr=chunkLenStr.trim();
    int chunkLen;
    try {
      chunkLen=Integer.parseInt(chunkLenStr,16);
    }
 catch (    NumberFormatException e) {
      throw new HttpException("bad chunk length: " + line.toString());
    }
    if (chunkLen == 0) {
      doneChunks=true;
      break;
    }
    if (http.getMaxContent() >= 0 && (contentBytesRead + chunkLen) > http.getMaxContent())     chunkLen=http.getMaxContent() - contentBytesRead;
    int chunkBytesRead=0;
    while (chunkBytesRead < chunkLen) {
      int toRead=(chunkLen - chunkBytesRead) < Http.BUFFER_SIZE ? (chunkLen - chunkBytesRead) : Http.BUFFER_SIZE;
      int len=in.read(bytes,0,toRead);
      if (len == -1)       throw new HttpException("chunk eof after " + contentBytesRead + " bytes in successful chunks"+ " and "+ chunkBytesRead+ " in current chunk");
      out.write(bytes,0,len);
      chunkBytesRead+=len;
    }
    readLine(in,line,false);
  }
  if (!doneChunks) {
    if (contentBytesRead != http.getMaxContent())     throw new HttpException("chunk eof: !doneChunk && didn't max out");
    return;
  }
  content=out.toByteArray();
  parseHeaders(in,line);
}
