{
  long now=System.currentTimeMillis();
  CrawlDbUpdateUtil<CrawlDbReducer> updateDb=new CrawlDbUpdateUtil<CrawlDbReducer>(new CrawlDbReducer(),configuration);
  CrawlDatum dbDatum=new CrawlDatum();
  dbDatum.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);
  schedule.initializeSchedule(dummyURL,dbDatum);
  dbDatum.setFetchTime(now);
  LOG.info("Emulate a continuous crawl, launched every " + (interval / (FetchSchedule.SECONDS_PER_DAY * 1000)) + " day ("+ (interval / 1000)+ " seconds)");
  long maxTime=(now + duration);
  long nextTime=now;
  long lastFetchTime=-1;
  boolean ok=true;
  CrawlDatum fetchDatum=new CrawlDatum();
  CrawlDatum copyDbDatum=new CrawlDatum();
  CrawlDatum copyFetchDatum=new CrawlDatum();
  CrawlDatum afterShouldFetch=new CrawlDatum();
  int errorCount=0;
  while (nextTime < maxTime) {
    LOG.info("check: " + new Date(nextTime));
    fetchDatum.set(dbDatum);
    copyDbDatum.set(dbDatum);
    if (schedule.shouldFetch(dummyURL,fetchDatum,nextTime)) {
      LOG.info("... fetching now (" + new Date(nextTime) + ")");
      if (lastFetchTime > -1) {
        LOG.info("(last fetch: " + new Date(lastFetchTime) + " = "+ TimingUtil.elapsedTime(lastFetchTime,nextTime)+ " ago)");
      }
      lastFetchTime=nextTime;
      afterShouldFetch.set(fetchDatum);
      fetchDatum=fetch(fetchDatum,nextTime);
      copyFetchDatum.set(fetchDatum);
      List<CrawlDatum> values=new ArrayList<CrawlDatum>();
      values.add(dbDatum);
      values.add(fetchDatum);
      values.addAll(parse(fetchDatum));
      List<CrawlDatum> res=updateDb.update(values);
      assertNotNull("null returned",res);
      assertFalse("no CrawlDatum",0 == res.size());
      assertEquals("more than one CrawlDatum",1,res.size());
      if (!check(res.get(0))) {
        LOG.info("previously in CrawlDb: " + copyDbDatum);
        LOG.info("after shouldFetch(): " + afterShouldFetch);
        LOG.info("fetch: " + fetchDatum);
        LOG.warn("wrong result in CrawlDb: " + res.get(0));
        if (++errorCount >= maxErrors) {
          if (maxErrors > 0) {
            LOG.error("Max. number of errors " + maxErrors + " reached. Stopping.");
          }
          return false;
        }
 else {
          ok=false;
        }
      }
      dbDatum=res.get(0);
    }
    nextTime+=interval;
  }
  return ok;
}
